# 存储优化

## 实验介绍

### 实验内容



### 实验知识点

+ ​




## 创建具有最优性能的表空间

在创建表空间时，最好是使用本地管理和  ASSM （Auto Segment Space Management 自动段空间管理）。Oracle 12c 中默认就是这种管理方式，如下所示：

```bash
$ sudo su oracle
$ sqlplus system/Syl12345
```

```sql
SQL> create tablespace autoex datafile 'autoex.dbf' size 1m;

Tablespace created.

SQL> select tablespace_name,extent_management,segment_space_management from dba_tablespaces wher
e tablespace_name='AUTOEX';

TABLESPACE_NAME        EXTENT_MAN SEGMEN
---------------------- ---------- ------
AUTOEX                  LOCAL      AUTO
```

## 行链接与行迁移

### 简介

当我们在插入一行记录时，如果一个块的空闲空间不足以存放进这一行记录的话，Oracle 就会去链接一个或多个这个段中保留的块来存储这一行记录。这就是`行链接`。

当一行原本存放在一个块中的记录，由于更新操作导致行长变大，而这个块已经容纳不下时，Oracle 会把这行记录存放到一个空间足够的新块中。这就是`行迁移`。

可想而知，如果产生行链接或者行迁移是很消耗性能的，因为数据库需要扫描更多的块来获取某一行记录。

行链接和行迁移有两个相关的存储参数：

- `PCTFREE` ：为更新已存在的数据预留空间的百分比。
- `PCTUSED` ：用于插入数据的最小空间的百分比。

我们可以将块比作水杯，向块添加数据比作向水杯加水，假设 PCTFREE 设定是 20 ，则当我们将水添加到 80% 的时候，就不能再添加，剩余的 20% 是用来为更新数据预留的空间。假设 PCTUSED 设定的 60 ，则当我们将水喝到只剩 60% 的时候，就可以加水了。

### 场景

楼狮狮是一个数据库管理员，某天他根据统计报告发现了 I/O 活动增大了不少，检查行链接和行转移后发现是由于 PCFREE 的配置有问题，导致发生过多的行迁移和行链接，从而导致 I/O 增大。那么如何检测行迁移以及行链接，并且解决掉此问题呢。

#### 检测行迁移以及行链接

首先我们要构建一个测试场景来模拟出行链接和行转移的问题。先来建一个测试表，并添加一些测试数据。

```bash
$ sudo su oracle
$ sqlplus system/Syl12345
```

```sql
--创建测试表
SQL> create table rowtest(id number,note varchar2(2000))pctfree 10;

--添加测试数据
SQL> begin
  for i in 1..30000 loop
    insert into rowtest values(
      i,'shiyanlou test test test' );
  end loop;
  commit;
end;
  /
  
--可以看到已经插入 30000 条数据
SQL> select count(*) from rowtest;
```

我们来查看以下该表的统计信息：

```sql
--分析 rowtest 这张表
SQL> analyze table rowtest compute statistics;

--查看分析出来的统计信息
SQL> select num_rows,blocks,empty_blocks,chain_cnt,round(chain_cnt/num_rows*100,2) "chain_pct(%)
",pct_free from user_tables where table_name='ROWTEST';

  NUM_ROWS     BLOCKS EMPTY_BLOCKS  CHAIN_CNT chain_pct(%)   PCT_FREE
---------- ---------- ------------ ---------- ------------ ----------
  30000          147       108          0          0           10
```

> `chain_cnt` 就是表中出现的行链接和行迁移的总和。这里是 0 说明此时并为发生行链接和行迁移。
>
> `chain_pct(%)` 是发生行链接和行迁移的百分比。一般超过 `15%` ，就会存在问题。

接下来通过更新大量数据来让表产生行迁移和行链接，以模拟行迁移和行链接出现过多的场景。

```sql
SQL> begin
  for i in 1..10000 loop
    update rowtest set
      note=note || note ||note || note
      where id=i;
  end loop;
  commit;
end;
/
```

我们再次查看表的统计信息：

```sql
SQL> analyze table rowtest compute statistics;

SQL> select num_rows,blocks,empty_blocks,chain_cnt,round(chain_cnt/num_rows*100,2) "chain_pct(%)
",pct_free  from user_tables where table_name='ROWTEST';

  NUM_ROWS     BLOCKS EMPTY_BLOCKS  CHAIN_CNT chain_pct(%)   PCT_FREE
---------- ---------- ------------ ---------- ------------ ----------
     30000      280       103           7184      23.95        10
```

可以看到有 7184 行发生了行链接和行迁移，百分比达到了 23.95% ，已经超过 15% 。

我们可以创建一张表来存放 ANALYZE TABLE 的输出：

```sql
--调用 oracle 提供的 utlchn1.sql 脚本创建一张名为 chained_rows 的表来存放输出。
SQL> @?/rdbms/admin/utlchn1.sql

Table created.

--将行迁移和行链接的数据行填充到 chained_rows 表中。
SQL> analyze table rowtest list chained rows;

Table analyzed.

--查看 chained_rows 表中一共有多少行，也就是发生行迁移和行链接的行数。
SQL> select count(*) from chained_rows where table_name='ROWTEST';

  COUNT(*)
----------
      7184
```








## 总结

